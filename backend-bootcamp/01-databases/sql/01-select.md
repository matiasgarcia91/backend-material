---
title: Basic statements
---

# `CREATE TABLE` and `INSERT`

Make sure you try the example queries. Start a PostgreSQL instance and connect to it with a visual client. Let's start by examining a statement that creates a new table.

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  birth_date DATE
);
```

The name of the table is `users`. The table has 4 columns. The column called `id` is also the table's _primary key_. The data type of the `id` column is `SERIAL`. This is a special numeric type. For every row inserted into this table, the database will generate a new unique number. This makes it ideal as a `PRIMARY KEY`. The term _key_ here refers to the same concept as "key value pairs". Given a key, you can find a value in a table. Keys must be unique.

The following statement inserts four new rows into the `users` table.

```sql
INSERT INTO users (first_name, last_name, birth_date) VALUES
  ('Floor', 'Visser', '1986-07-22'),
  ('Floor', 'Valk', '1983-04-13'),
  ('Floris', 'Vos', '1983-04-13'),
  ('Fatima', 'Voorthuizen', '1956-12-16');
```

The statement starts with the table name and a list of column names. This list tells the database how it should interpret the sets of values that follow. Every row after `VALUES` is enclosed in parentheses. In this example we specify four rows to be inserted using a single `INSERT`-statement. Notice that we're not specifying values for the `id` column. This is because, as said before, the `SERIAL` type will have its values automatically generated by the database.

# `SELECT`

Here is how we get all the columns of every row:

```sql
SELECT *
FROM users;
```

Effectively, we just get the entire table back. And we've also learned an important fact: _SQL queries always result in tabular data._ In this case, the exact same data as the table itself.

And this is how you select only specific columns:

```sql
SELECT first_name, last_name
FROM users;
```

We can also order the rows:

```sql
SELECT first_name, last_name
FROM users
ORDER BY birth_date;
```

(Quick question: How would you order the columns?)

<MultiChoice
  id="1563874602695"
  question="By analogy, which FP-style JavaScript expression would this last SQL query most resemble?"
  options={[
    <Markdown>
    ```js.slim
    users
      .slice().sort((user_a, user_b) => user_a.birth_date > user_b.birth_date)
      .map(user => ({ first_name: user.first_name, last_name: user.last_name }))
    ```
    </Markdown>,
    <Markdown>
    ```js.slim
    users
      .map(user => ({ first_name: user.first_name, last_name: user.last_name }))
    ```
    </Markdown>,
    <Markdown>
    ```js.slim
    users
      .slice().sort((user_a, user_b) => user_a.birth_date > user_b.birth_date)
    ```
    </Markdown>
  ]}
  singleColumn
  shuffle
  correctIndex={0}
/>

The last query above will order the rows by birth date, and by default it will respond with the rows in **asc**ending order: lowest value first, so in this case oldest people first. (Note how it's not necessary to _select_ the birth date column in order to order by the birth date.) If you want sort in **desc**ending order, you can say so:

```sql
SELECT first_name, last_name
FROM users
ORDER BY birth_date DESC;
```

If you look at our dataset, you would not be able to predict which row would come first: "Floor Valk" or "Floris Vos". The reason: they both have the _same_ birth date. To address this, you can order by multiple columns:

```sql
SELECT first_name, last_name
FROM users
ORDER BY
  birth_date DESC,
  last_name ASC;
```

Now Floor V**a**lk is guaranteed to come before Floris V**o**s. Changing the ordering direction of the secondary column (in this case: `last_name`) lets you control the order of rows that have the same value for the primary ordering column.

We can filter the rows using a `WHERE`-clause:

```sql
SELECT first_name, last_name
FROM users
WHERE first_name = 'Floor'
ORDER BY
  birth_date DESC,
  last_name ASC;
```

This `WHERE`-clause uses a simple comparison between the value in the query, and the values in the table cells. Rows where the values match will be returned, the others will not. If you're coming from a programming language, it may be worth pointing out that the syntax for comparison uses a _single_ `=` symbol.

<MultiChoice
  id="1563875584700"
  question="By analogy, which FP-style JavaScript expression would this last SQL query most resemble?"
  options={[
    <Markdown>
    ```js.slim
    users
      .filter(user => user.first_name === "Floor")
      .slice().sort(myUserSortFn)
      .map(user => ({ first_name: user.first_name, last_name: user.last_name }))
    ```
    </Markdown>,
    <Markdown>
    ```js.slim
    users
      .map(user => ({ first_name: user.first_name, last_name: user.last_name }))
      .slice().sort(myUserSortFn)
      .filter(user => user.first_name === "Floor")
    ```
    </Markdown>,
    <Markdown>
    ```js.slim
    users
      .filter(user => user.first_name === "Floor")
      .slice().sort(myUserSortFn)
    ```
    </Markdown>
  ]}
  singleColumn
  shuffle
  correctIndex={0}
/>

You can do numeric comparisons as well as having compound boolean expressions. Consider the following query:

```sql
SELECT *
FROM money_transfers
WHERE amount > 1000 AND destination_account <> 'NL ABNA46 056 000 000 000';
```

Again, coming from a programming language, checking for inequality might look a bit odd to you: `<>` instead of `!=` or `!==`.

Here is an example of using a "wild-card" to do string comparison with `LIKE`:

```sql
SELECT *
FROM users
WHERE first_name LIKE 'Fl%';
```

There's a case-insensitive version of `LIKE` âžœ `ILIKE`:

```sql
SELECT *
FROM users
WHERE first_name ILIKE 'fl%';
```

# `DROP TABLE`
During development you'll often create, delete, and re-create tables. To drop a table (aka "delete the table including all data in it"), say whose name is `users`, the statement to use is:

```sql
DROP TABLE users;
```


## Exercise: Write `SELECT`-statements

Use this dataset:

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  created_at TIMESTAMP,
  name TEXT,
  description TEXT,
  price DECIMAL(12,2)
);

INSERT INTO products
  (created_at, name, description, price)
VALUES
  ('2017-01-01', 'Hammer', 'This green hammer is amazing for sustainable businesses that want to make a dent in the universe', 10),
  ('2017-02-02', 'Hammer', 'This red hammer is amazing for people that just don''t like another color' , 12.4),
  ('2017-06-06', 'Xylophone', 'If you like things that start with an X, buy this', 10),
  ('2017-05-05', 'LP of John Lenon', 'This totally green piece of history is pure perfection', 10),
  ('2017-04-04', 'Linkin Park CD', 'Sometimes it doesn''t even matter, as long as it''s Green (with a capital g)', 9.67)
;
```

_Notice how the apostrophe in the string is being escaped_

Write queries to perform the following searches

1. Only retrieve the columns `name` and `price`
2. Only retrieve the products that are cheaper than 10 EU
3. Order the products by `price`. Show the cheapest products first, the most expensive last
4. Like above, but additionally, if two products have the same `price`, show the newest product first
5. Only retrieve products that have the word 'green' anywhere in the description, where it doesn't matter whether capitals or lowercase letters are used
